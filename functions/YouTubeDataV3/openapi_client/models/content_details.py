# coding: utf-8
"""
    YouTube Data API v3

    See. [YouTube Data API v3](https://developers.google.com/youtube/v3)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any
from typing import ClassVar
from typing import Dict
from typing import List
from typing import Optional

from openapi_client.models.content_details_region_restriction import (
    ContentDetailsRegionRestriction,
)
from openapi_client.models.content_rating import ContentRating
from pydantic import BaseModel
from pydantic import Field
from pydantic import field_validator
from pydantic import StrictBool
from pydantic import StrictStr

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class ContentDetails(BaseModel):
    """
    The contentDetails object contains information about the video content, including the length of the video and an indication of whether captions are available for the video.
    """  # noqa: E501

    duration: Optional[StrictStr] = Field(
        default=None,
        description="The length of the video. The property value is an ISO 8601 duration. For example, for a video that is at least one minute long and less than one hour long, the duration is in the format `PT#M#S`, in which the letters PT indicate that the value specifies a period of time, and the letters M and S refer to length in minutes and seconds, respectively. The # characters preceding the M and S letters are both integers that specify the number of minutes (or seconds) of the video. For example, a value of `PT15M33S` indicates that the video is 15 minutes and 33 seconds long. If the video is at least one hour long, the duration is in the format PT#H#M#S, in which the # preceding the letter H specifies the length of the video in hours and all of the other details are the same as described above. If the video is at least one day long, the letters P and T are separated, and the value's format is P#DT#H#M#S. Please refer to the ISO 8601 specification for complete details.",
    )
    dimension: Optional[StrictStr] = Field(
        default=None,
        description="Indicates whether the video is available in 3D or in 2D.",
    )
    definition: Optional[StrictStr] = Field(
        default=None,
        description="Indicates whether the video is available in high definition (HD) or only in standard definition. Valid values for this property are: - `hd` - `sd`",
    )
    caption: Optional[StrictStr] = Field(
        default=None,
        description="Indicates whether captions are available for the video. Valid values for this property are: - `false` - `true`",
    )
    licensed_content: Optional[StrictBool] = Field(
        default=None,
        description="Indicates whether the video represents licensed content, which means that the content was uploaded to a channel linked to a YouTube content partner and then claimed by that partner.",
        alias="licensedContent",
    )
    region_restriction: Optional[ContentDetailsRegionRestriction] = Field(
        default=None, alias="regionRestriction"
    )
    content_rating: Optional[ContentRating] = Field(default=None, alias="contentRating")
    projection: Optional[StrictStr] = Field(
        default=None,
        description="Specifies the projection format of the video. Valid values for this property are: - `360` - `rectangular`",
    )
    has_custom_thumbnail: Optional[StrictBool] = Field(
        default=None,
        description="Indicates whether the video uploader has provided a custom thumbnail image for the video. This property is only visible to the video uploader.",
        alias="hasCustomThumbnail",
    )
    __properties: ClassVar[List[str]] = [
        "duration",
        "dimension",
        "definition",
        "caption",
        "licensedContent",
        "regionRestriction",
        "contentRating",
        "projection",
        "hasCustomThumbnail",
    ]

    @field_validator("definition")
    def definition_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ("hd", "sd"):
            raise ValueError("must be one of enum values ('hd', 'sd')")
        return value

    @field_validator("caption")
    def caption_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ("false", "true"):
            raise ValueError("must be one of enum values ('false', 'true')")
        return value

    model_config = {"populate_by_name": True, "validate_assignment": True}

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ContentDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of region_restriction
        if self.region_restriction:
            _dict["regionRestriction"] = self.region_restriction.to_dict()
        # override the default output from pydantic by calling `to_dict()` of content_rating
        if self.content_rating:
            _dict["contentRating"] = self.content_rating.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ContentDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "duration": obj.get("duration"),
                "dimension": obj.get("dimension"),
                "definition": obj.get("definition"),
                "caption": obj.get("caption"),
                "licensedContent": obj.get("licensedContent"),
                "regionRestriction": ContentDetailsRegionRestriction.from_dict(
                    obj.get("regionRestriction")
                )
                if obj.get("regionRestriction") is not None
                else None,
                "contentRating": ContentRating.from_dict(obj.get("contentRating"))
                if obj.get("contentRating") is not None
                else None,
                "projection": obj.get("projection"),
                "hasCustomThumbnail": obj.get("hasCustomThumbnail"),
            }
        )
        return _obj
