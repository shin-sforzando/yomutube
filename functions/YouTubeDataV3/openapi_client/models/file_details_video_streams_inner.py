# coding: utf-8
"""
    YouTube Data API v3

    See. [YouTube Data API v3](https://developers.google.com/youtube/v3)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any
from typing import ClassVar
from typing import Dict
from typing import List
from typing import Optional
from typing import Union

from pydantic import BaseModel
from pydantic import Field
from pydantic import field_validator
from pydantic import StrictFloat
from pydantic import StrictInt
from pydantic import StrictStr

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class FileDetailsVideoStreamsInner(BaseModel):
    """
    FileDetailsVideoStreamsInner
    """  # noqa: E501

    width_pixels: Optional[StrictInt] = Field(
        default=None,
        description="The encoded video content's width in pixels. You can calculate the video's encoding aspect ratio as `width_pixels` / `height_pixels`.",
        alias="widthPixels",
    )
    height_pixels: Optional[StrictInt] = Field(
        default=None,
        description="The encoded video content's height in pixels.",
        alias="heightPixels",
    )
    frame_rate_fps: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="The video stream's frame rate, in frames per second.",
        alias="frameRateFps",
    )
    aspect_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="The video content's display aspect ratio, which specifies the aspect ratio in which the video should be displayed.",
        alias="aspectRatio",
    )
    codec: Optional[StrictStr] = Field(
        default=None, description="The video codec that the stream uses."
    )
    bitrate_bps: Optional[StrictInt] = Field(
        default=None,
        description="The video stream's bitrate, in bits per second.",
        alias="bitrateBps",
    )
    rotation: Optional[StrictStr] = Field(
        default=None,
        description="The amount that YouTube needs to rotate the original source content to properly display the video. Valid values for this property are: - `none` - The video does not need to be rotated. - `clockwise` - The video needs to be rotated 90 degrees clockwise. - `counterClockwise` - The video needs to be rotated 90 degrees counter-clockwise. - `other` - The video needs to be rotated in some other, non-trivial way. - `upsideDown` - The video needs to be rotated upside down.",
    )
    vendor: Optional[StrictStr] = Field(
        default=None,
        description="A value that uniquely identifies a video vendor. Typically, the value is a four-letter vendor code.",
    )
    __properties: ClassVar[List[str]] = [
        "widthPixels",
        "heightPixels",
        "frameRateFps",
        "aspectRatio",
        "codec",
        "bitrateBps",
        "rotation",
        "vendor",
    ]

    @field_validator("rotation")
    def rotation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in (
            "none",
            "clockwise",
            "counterClockwise",
            "other",
            "upsideDown",
        ):
            raise ValueError(
                "must be one of enum values ('none', 'clockwise', 'counterClockwise', 'other', 'upsideDown')"
            )
        return value

    model_config = {"populate_by_name": True, "validate_assignment": True}

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of FileDetailsVideoStreamsInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of FileDetailsVideoStreamsInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "widthPixels": obj.get("widthPixels"),
                "heightPixels": obj.get("heightPixels"),
                "frameRateFps": obj.get("frameRateFps"),
                "aspectRatio": obj.get("aspectRatio"),
                "codec": obj.get("codec"),
                "bitrateBps": obj.get("bitrateBps"),
                "rotation": obj.get("rotation"),
                "vendor": obj.get("vendor"),
            }
        )
        return _obj
