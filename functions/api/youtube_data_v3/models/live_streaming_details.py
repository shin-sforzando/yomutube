# coding: utf-8
"""
    YouTube Data API v3

    See. [YouTube Data API v3](https://developers.google.com/youtube/v3)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import datetime
from typing import Any
from typing import ClassVar
from typing import Dict
from typing import List
from typing import Optional

from pydantic import BaseModel
from pydantic import Field
from pydantic import StrictInt
from pydantic import StrictStr

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class LiveStreamingDetails(BaseModel):
    """
    The liveStreamingDetails object contains metadata about a live video broadcast. The object will only be present in a `video` resource if the video is an upcoming, live, or completed live broadcast.
    """  # noqa: E501

    actual_start_time: Optional[datetime] = Field(
        default=None,
        description="The time that the broadcast actually started. The value is specified in ISO 8601 format. This value will not be available until the broadcast begins.",
        alias="actualStartTime",
    )
    actual_end_time: Optional[datetime] = Field(
        default=None,
        description="The time that the broadcast actually ended. The value is specified in ISO 8601 format. This value will not be available until the broadcast is over.",
        alias="actualEndTime",
    )
    scheduled_start_time: Optional[datetime] = Field(
        default=None,
        description="The time that the broadcast is scheduled to begin. The value is specified in ISO 8601 format.",
        alias="scheduledStartTime",
    )
    scheduled_end_time: Optional[datetime] = Field(
        default=None,
        description="The time that the broadcast is scheduled to end. The value is specified in ISO 8601 format. If the value is empty or the property is not present, then the broadcast is scheduled to continue indefinitely.",
        alias="scheduledEndTime",
    )
    concurrent_viewers: Optional[StrictInt] = Field(
        default=None,
        description="The number of viewers currently watching the broadcast. The property and its value will be present if the broadcast has current viewers and the broadcast owner has not hidden the `viewCount` for the video. Note that YouTube stops tracking the number of concurrent viewers for a broadcast when the broadcast ends. So, this property would not identify the number of viewers watching an archived video of a live broadcast that already ended.",
        alias="concurrentViewers",
    )
    active_live_chat_id: Optional[StrictStr] = Field(
        default=None,
        description="The ID of the currently active live chat attached to this video. This field is filled only if the video is a currently live broadcast that has live chat. Once the broadcast transitions to complete this field will be removed and the live chat closed down. For persistent broadcasts that live chat id will no longer be tied to this video but rather to the new video being displayed at the persistent page.",
        alias="activeLiveChatId",
    )
    __properties: ClassVar[List[str]] = [
        "actualStartTime",
        "actualEndTime",
        "scheduledStartTime",
        "scheduledEndTime",
        "concurrentViewers",
        "activeLiveChatId",
    ]

    model_config = {"populate_by_name": True, "validate_assignment": True}

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of LiveStreamingDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of LiveStreamingDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "actualStartTime": obj.get("actualStartTime"),
                "actualEndTime": obj.get("actualEndTime"),
                "scheduledStartTime": obj.get("scheduledStartTime"),
                "scheduledEndTime": obj.get("scheduledEndTime"),
                "concurrentViewers": obj.get("concurrentViewers"),
                "activeLiveChatId": obj.get("activeLiveChatId"),
            }
        )
        return _obj
